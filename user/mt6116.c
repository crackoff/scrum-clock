////Пример программы для вывода картинки на индикатор MT-6116
//
//void main(void) {
//byte	p;//Номер текущей страницы индикатора
//byte	c;//Позиция по горизонтали выводимого байта
//
//	LCDinit();
//	for(p=0; p<2; p++) {//Цикл по всем 2-м страницам индикатора
//		WriteCode(p|0xB8);//Установка текущей страницы для обоих кристаллов индикатора
//		WriteCode(0x00);//Установка текущего адреса для записи данных в 0
//		for(c=0; c<61; c++) {//Цикл вывода
//			WriteData(Logo61[p][c]);//Вывод очередного байта в индикатор
//		}
//	}
//}
//
////Процедура программной инициализации индикатора
//void LCDinit(void) {
//	LCD.E=0;//Начальное значение сигнала индикатору
//	LCD.RES=0;//Выдать сигнал RES=0 индикатору
//	Delay(>10us);//Задержка на время больше 10 мкс
//	LCD.RES=1;//Снять сигнал RES
//	Delay(>1ms);//Задержка на время больше 1 мс
//	WriteCode(0xE2);//Reset
//	WriteCode(0xEE);//ReadModifyWrite off
//	WriteCode(0xA4);//Включить обычный режим
//	WriteCode(0xA8);//Мультиплекс 1/16
//	WriteCode(0xC0);//Верхнюю строку на 0
//	WriteCode(0xA0);//NonInvert scan RAM
//	WriteCode(0xAF);//Display on
//}
//
//void Pset(byte x, byte y, bit c) {//Записать одну точку в индикатор (координата 0,0 в левом верхнем углу индикатора)
//byte c8;//Временное хранение считаного из индикатора байта
//byte m8;//Маска нужного бита в байте
//	if ((x>60)||(y>15)) return;//Выход за пределы индикатора
//	WriteCode(0xB8|(y>>3));//Установить нужную страницу индикатора
//	WriteCode(x);//Установить адрес нужного байта
//	c8=ReadData();//Фиктивное чтение
//	c8=ReadData();//Чтение нужного байта из индикатора
//	m8=1<<(y&0x07);//Вычислить маску нужного бита в байте
//	if (c==1)	//Зажигать точку?
//		c8|=m8//Установить нужный бит в байте
//	else		//Или гасить точку?
//		c8&=~m8;//Сбросить нужный бит в байте
//	WriteCode(x);//Снова установить адрес нужного байта
//	WriteData(c8);//Записать изменћнный байт обратно в индикатор
//}
//
//void WriteCode(byte b) { WriteByte(b,0); }
//
//void WriteData(byte b) { WriteByte(b,1); }
//
//byte ReadData(void) { return ReadByte(1); }//Прочитать байт данных из индикатора
//
////Процедура выдачи байта в индикатор
//void WriteByte(byte b, bit cd) {
//	WaitReady();		//Ждать готовности индикатора
////При необходимости настроить здесь шину данных на вывод
//	LCD.RW=0; LCD.A0=cd;	//Выдача байта в индикатор как данных или команды
//	LCD.D=b;		//Выдать байт на шину данных индикатора
//	Delay(>40ns);		//Это время предустановки адреса (tAW)
//	LCD.E=1; Delay(>160ns);	//Длительность сигнала E=1 (время предустановки данных попало сюда (tDS))
//	LCD.E=0; Delay(>(2000ns-40ns-160ns));	//Минимально допустимый интервал между сигналами E=1
//}
//
//byte ReadByte(bit cd) {
//byte b;
//	WaitReady();		//Ждать готовности индикатора
//	LCD.RW=1; LCD.A0=cd;	//Будем читать байт как команду или данные
//	Delay(>40ns);		//Это время предустановки адреса (tAW)
//	LCD.E=1; 		//Выдать строб в индикатор
//	Delay(>300ns);		//Минимально допустимая длительность сигнала E=1 (время доступа (tACC) попало сюда)
//	b=LCD.D;		//Прочитать данные с шины индикатора (они на ней уже минимум 120нс)
//	LCD.E=0;		//Сбросить сигнал E
//	Delay(>(2000ns-40ns-300ns));	//Минимально допустимый интервал между сигналами E=1
//	return b;		//Вернуть прочитанный байт
//}
//
//void WaitReady(void) {//Ждать готовности индикатора, опрашивая байт статуса
////При необходимости настроить здесь шину данных на ввод
//	LCD.RW=1; LCD.A0=0;	//Чтение флага занятости
//	Delay(>40ns);		//Это время предустановки адреса (tAW)
//	LCD.E=1; Delay(>300ns);	//Минимально допустимая длительность сигнала E=1 (время доступа (tACC) попало сюда)
//	while(LCD.D.7==1);	//Ждать сброса флага занятости
//	LCD.E=0; Delay(>(2000ns-40ns-300ns));	//Минимально допустимый интервал между сигналами E=1
//}
//
////Данные изображения, побитые по строкам и байты будут на индикаторе вертикально.
////Это просто последовательность байт для записи в индикатор начиная с верхней страницы.
////Полностью соответствуют картинке распределения ОЗУ в документации на модуль.
//const byte Logo61[2][61]=//61x16 pixel, каждые 8 вертикальных точек собраны в байт
//{
//	{	0xF8,0xFC,0xFE,0xFB,0xEF,0x7F,0x1F,0x0F,0x0F,0x3F,
//		0x1F,0x0F,0xBE,0x0C,0x18,0xE0,0x00,0x00,0x08,0x88,
//		0xE8,0xE8,0xE8,0x08,0x88,0xE8,0xE8,0xE8,0x08,0x08,
//		0xC8,0xE8,0xE8,0x68,0x68,0x68,0x68,0xE8,0xC8,0xC8,
//		0x88,0x08,0x08,0x08,0x08,0x88,0xC8,0xE8,0xE8,0xE8,
//		0x68,0x68,0x68,0x68,0xE8,0xE8,0xE8,0x68,0x68,0x68,
//		0x68
//	},
//	{	0x0F,0x18,0x27,0x4F,0x43,0x80,0x80,0x80,0x80,0x80,
//		0x80,0x40,0x40,0xE8,0xFC,0xFF,0x7C,0x1E,0x0F,0x07,
//		0xFF,0xFF,0xFF,0x1F,0x0F,0xFF,0xFF,0xFF,0x00,0x20,
//		0x70,0x70,0xE6,0xCE,0xCE,0xCE,0xCE,0xE4,0x71,0x3F,
//		0xFF,0xF0,0xF8,0x7C,0x3F,0x0F,0x07,0xFF,0xFF,0xFF,
//		0x00,0x00,0x00,0x00,0xFF,0xFF,0xFF,0x00,0x00,0x00,
//		0x00
//	}
//};
